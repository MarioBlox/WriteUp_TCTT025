# 🧩 Zipception — Nested ZIP Chain (6277)

โจทย์สไตล์ซิปซ้อนซิป (zip-ception) ไล่แตกทีละชั้นจนสุดทาง 🎯  
เป้าหมาย: แตกไฟล์ `*.zip` ไล่ลงไปจนเจอไฟล์สุดท้าย และอ่าน Flag

---

## 📁 ไฟล์โจทย์

| File | Size | SHA-256 |
|------|------|---------|
| `6277.zip` | 1841849 bytes | `f27b51015678eb20f8e4f23d85198d60c38bc76727ef0c108d212d80c6230f35` |

> หมายเหตุ: ไฟล์สุดท้ายหลังแกะสำเร็จถูกเซฟไว้เพื่ออ้างอิง:
>
> - Path: `final_from_6277/output_6278`  
> - Size: 45 bytes  
> - SHA-256: `c77a06cf14fcc901ccc9e393ceb08c1d0b4e4f5932439ee2b6898d49c0a5e0bf`

---

## ⚡ TL;DR (ทำเร็ว เอาให้จบ)

```bash
# ใช้ Python ไล่แตกซิปจนกว่าจะไม่ใช่ .zip (บันทึกไฟล์ทั้งหมดลงโฟลเดอร์)
python3 nested_unzip.py
```

**✅ Flag**
```
flag{n07h!in9_b347_j37_7w0_h01!d4y_627846261}
```

---

## 🧠 ไอเดียหลัก (สั้นและตรงประเด็น)

- โจทย์คือ “ซิปซ้อนซิป” จำนวนหลายพันชั้น (เริ่มที่ `6277.zip`)  
- แตกไฟล์ซิปชั้นปัจจุบัน → ได้ไฟล์ถัดไป → ถ้ายังเป็น `.zip` ก็แตกต่อ วนไปจนเจอไฟล์ที่ **ไม่ใช่ zip**  
- ไฟล์ชั้นสุดท้ายเป็นข้อความล้วนและมี **Flag** อยู่ภายใน

---

## 🪜 Step-by-step

1. เตรียมโฟลเดอร์ `unzipped/` สำหรับเก็บไฟล์ที่แตกทุกรอบ  
2. เปิดซิปไฟล์ปัจจุบัน (เริ่มจาก `6277.zip`) แล้วแตกออกทั้งหมด  
3. อ่านชื่อไฟล์ตัวแรกใน zip (เช่น `6276.zip`) ตั้งเป็นไฟล์ถัดไป  
4. ถ้าชื่อถัดไปยังลงท้าย `.zip` ให้กลับไปข้อ 2
5. ถ้าไม่ใช่ `.zip` → นี่คือ **ไฟล์สุดท้าย** → เปิดอ่านเพื่อเก็บ Flag

---

## 🧰 เครื่องมือที่ใช้ได้

- Python 3.8+
- โมดูลมาตรฐาน: `zipfile`, `os` (พอแล้ว)
- (ทางเลือก) สคริปต์แบบ **in‑memory** ไม่สร้างไฟล์ระหว่างทาง เร็วกว่าเครื่องมือแตกลงดิสก์

---

## 🐍 โค้ด Python (แบบบันทึกลงโฟลเดอร์)

> ปรับ `file` ให้ตรงชื่อไฟล์เริ่มต้น เช่น `6277.zip`

```python
import zipfile
import os

file = "6277.zip"
outdir = "unzipped"

os.makedirs(outdir, exist_ok=True)

for i in range(7000):
    if not file.lower().endswith(".zip"):
        print(f"[DONE] Extracted final file: {file}")
        break

    with zipfile.ZipFile(file, 'r') as zf:
        zf.extractall(outdir)
        next_file = zf.namelist()[0]

    file = os.path.join(outdir, next_file)
```

---

## ⚡ โค้ด Python (แบบ in‑memory เร็วมาก)

```python
import io, zipfile

with open("6277.zip", "rb") as f:
    current = f.read()

for depth in range(20000):
    bio = io.BytesIO(current)
    if not zipfile.is_zipfile(bio):
        # ถึงไฟล์สุดท้ายแล้ว (ไม่ใช่ zip) — พิมพ์ดู/บันทึกได้เลย
        try:
            print(current.decode("utf-8"))
        except UnicodeDecodeError:
            open("final_output.bin", "wb").write(current)
        break

    with zipfile.ZipFile(bio) as z:
        # หยิบ entry แรกเสมอ แล้วไล่ลงไป
        names = z.namelist()
        current = z.read(names[0])
```

> จุดแข็งของ in‑memory: เร็ว, ไม่สร้างไฟล์ขยะ, ใช้ IO น้อย เหมาะเมื่อชั้นซิปมีจำนวนมาก (เช่น ~6,000+)

---

## 📝 บทเรียนสั้นๆ

- โจทย์ “zip chain” มักให้ไล่ไฟล์ที่มีชื่อลดตัวเลขทีละ 1 (`6277 → 6276 → …`) จนสุดทาง
- วิธี in‑memory จะเร็วและเสถียรกว่าเมื่อชั้นเยอะมาก
- ตรวจว่าชั้นสุดท้ายเป็นข้อความหรือไบนารี — ถ้าเป็นข้อความ ให้ลอง `utf‑8` ก่อน

---

## 🛡️ Disclaimer

> เนื้อหานี้เพื่อการศึกษา/แข่งขัน CTF เท่านั้น ห้ามนำเทคนิคไปใช้กับระบบจริงโดยไม่ได้รับอนุญาต

---

## ✨ Author

**marioblox** — *zip spelunker* 🐱‍👤  
“แตกไปให้สุด แล้วหยุดที่ Flag” ✨
